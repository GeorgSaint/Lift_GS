Object subclass: #Lift	instanceVariableNames: 'currFloor destinationFloor manCount manMax goUp content'	classVariableNames: ''	poolDictionaries: ''	category: 'SLift-Model'!!Lift methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:10'!content	^ content! !!Lift methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:10'!content: anObject	content := anObject! !!Lift methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:10'!currFloor	^ currFloor! !!Lift methodsFor: 'accessing' stamp: 'ss 5/27/2009 11:14'!currFloor: anObject	"Transcript cr; show: 'lift move from - ', currFloor asString , ' to - ', anObject asString."	[self content liftSem refresh signal] on: Error do: [].	currFloor := anObject! !!Lift methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:10'!destinationFloor	^ destinationFloor! !!Lift methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:10'!destinationFloor: anObject	destinationFloor := anObject! !!Lift methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:10'!goUp	^ goUp! !!Lift methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:10'!goUp: anObject	goUp := anObject! !!Lift methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:10'!manCount	^ manCount! !!Lift methodsFor: 'accessing' stamp: 'ss 5/27/2009 11:15'!manCount: anObject	[self content liftSem refresh signal.] on: Error do: [].	manCount := anObject! !!Lift methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:11'!manMax	^ manMax! !!Lift methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:11'!manMax: anObject	manMax := anObject! !!Lift methodsFor: 'initialize-release' stamp: 'spectr 4/23/2009 23:11'!initialize	self currFloor: 1.	self destinationFloor: 1.	self manCount: 0.	self manMax: 5.	self goUp: true.! !!Lift methodsFor: 'creation' stamp: 'spectr 4/23/2009 23:40'!setContent: aContent	aContent class = LiftContent		ifTrue: [self content: aContent]		ifFalse: [^false].		^true.! !!Lift methodsFor: 'as yet unclassified' stamp: 'G.S. 3/29/2012 12:33'!isAllOut"is all people out from lift?"	self manCount = 0		ifTrue: [^true].			^self content unitOfWork allOutAt: self currFloor .! !!Lift methodsFor: 'as yet unclassified' stamp: 'G.S. 3/29/2012 12:34'!isCanGo"is all people who want in is in?"	^self content unitOfWork isAllIn ! !!Lift methodsFor: 'as yet unclassified' stamp: 'G.S. 3/29/2012 13:30'!isNotFull"is lift have place to get in?"	^self manCount < self manMax! !!Lift methodsFor: 'as yet unclassified' stamp: 'G.S. 3/29/2012 13:37'!moveNextFloor	"move to next floor"	| fisika |	fisika := LiftFisika new.	"expensive!!!!"	fisika calculate: self.	self currFloor: fisika currFloor.	self goUp: fisika goUp! !!Lift methodsFor: 'as yet unclassified' stamp: 'G.S. 3/29/2012 13:37'!testGo	(self content unitOfWork wantMoveFrom: self currFloor) = false ifFalse: 		[ (Delay forSeconds: 3) wait.		self moveNextFloor.		self content liftSem refresh signal ]! !!Lift methodsFor: 'as yet unclassified' stamp: 'G.S. 3/29/2012 13:31'!testIn	| sem |	sem := self content liftSem.	self isNotFull 		ifTrue: [(self content unitOfWork wantInAt: self currFloor)					ifTrue: [(sem canIn at: self currFloor) signal.							Transcript cr; show: 'canIn signal'.							(Delay forSeconds: 0.5) wait.							"sem  allIn wait."							[self isCanGo] whileFalse: [(Delay forSeconds: 5) wait.].							self content unitOfWork finishOn: self currFloor . "?"							sem  refresh signal.							(Delay forSeconds: 0.5) wait.]].! !!Lift methodsFor: 'as yet unclassified' stamp: 'ss 5/26/2009 03:25'!testOut	| sem |	sem := self content liftSem.	self manCount > 0		ifTrue: [(self content unitOfWork wantOutAt: self currFloor)					ifTrue: [(sem canOut at: self currFloor) signal .							Transcript cr; show: 'canOut signal'.							(Delay forSeconds: 0.5) wait.							"recalcul ? "							"sem refresh signal."							"sem allOut wait."							[self isAllOut] whileFalse: [(Delay forSeconds: 3) wait.].							"recalcul ?"							sem refresh signal.														(Delay forSeconds: 0.5) wait.]].! !!Lift methodsFor: 'as yet unclassified' stamp: 'G.S. 3/29/2012 13:31'!wantIn: aFloor 	"is this floor man want in and can in?"	aFloor = self currFloor ifFalse: [ ^ false ].		self isNotFull ifTrue: 		[ self content unitOfWork manGoToLiftAt: self currFloor.		self manCount: self manCount + 1.		^ true ].	^ false! !!Lift methodsFor: 'as yet unclassified' stamp: 'G.S. 3/29/2012 12:45'!wantOut: atFloor"is this floor that need man?"	self currFloor = atFloor 		ifTrue: [self manCount: self manCount - 1.				^true].			^false	! !!Lift methodsFor: 'as yet unclassified' stamp: 'G.S. 3/29/2012 12:45'!work	[true] whileTrue: 	[(Delay forSeconds: 1) wait. "time of waiting people"		self content unitOfWork modifyed 			ifFalse: [self content liftSem requests wait.]			ifTrue: [self content liftMine isOn				ifTrue: ["(Delay forSeconds: 1) wait."						self testOut .						self testIn .						self testGo .]]].					! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Lift class	instanceVariableNames: ''!!Lift class methodsFor: 'as yet unclassified' stamp: 'spectr 4/23/2009 23:43'!createWith: aContent	| model |	model := self new.	(model setContent: aContent) = false		ifTrue: [^false].	^model.! !Object subclass: #LiftContent	instanceVariableNames: 'lift liftMine unitOfWork liftSem proc ref'	classVariableNames: ''	poolDictionaries: ''	category: 'SLift-Model'!!LiftContent methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:27'!lift	^ lift! !!LiftContent methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:27'!lift: anObject	lift := anObject! !!LiftContent methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:27'!liftMine	^ liftMine! !!LiftContent methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:27'!liftMine: anObject	liftMine := anObject! !!LiftContent methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:27'!liftSem	^ liftSem! !!LiftContent methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:27'!liftSem: anObject	liftSem := anObject! !!LiftContent methodsFor: 'accessing' stamp: 'spectr 4/26/2009 17:41'!proc	^ proc! !!LiftContent methodsFor: 'accessing' stamp: 'spectr 4/26/2009 17:41'!proc: anObject	proc := anObject! !!LiftContent methodsFor: 'accessing' stamp: 'ss 5/27/2009 11:01'!ref	"Answer the value of ref"	^ ref! !!LiftContent methodsFor: 'accessing' stamp: 'ss 5/27/2009 11:01'!ref: anObject	"Set the value of ref"	ref _ anObject! !!LiftContent methodsFor: 'accessing' stamp: 'spectr 5/1/2009 13:59'!unitOfWork	unitOfWork isNil ifTrue: [self unitOfWork: (LiftUnitOfWork createWith: self).].	^ unitOfWork! !!LiftContent methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:27'!unitOfWork: anObject	unitOfWork := anObject! !!LiftContent methodsFor: 'initialize-release' stamp: 'ss 5/26/2009 00:34'!initialize	self liftMine: LiftMine new.	self liftSem: LiftSem new.	self lift: (Lift createWith: self).	self proc: self genProc.! !!LiftContent methodsFor: 'as yet unclassified' stamp: 'ss 5/26/2009 00:34'!genProc	^[self lift work] fork.! !!LiftContent methodsFor: 'as yet unclassified' stamp: 'spectr 4/26/2009 17:43'!killProc	self proc terminate.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LiftContent class	instanceVariableNames: ''!Object subclass: #LiftFisika	instanceVariableNames: 'currFloor destinationFloor manCount goUp'	classVariableNames: ''	poolDictionaries: ''	category: 'SLift-Model'!!LiftFisika commentStamp: 'G.S. 3/29/2012 12:30' prior: 0!A LiftFisika is lift behavior.Instance Variables	currFloor:		<Object>	destinationFloor:		<Object>	goUp:		<Object>	manCount:		<Object>currFloor	- xxxxxdestinationFloor	- xxxxxgoUp	- xxxxxmanCount	- xxxxx!!LiftFisika methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:12'!currFloor	^ currFloor! !!LiftFisika methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:12'!currFloor: anObject	currFloor := anObject! !!LiftFisika methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:12'!destinationFloor	^ destinationFloor! !!LiftFisika methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:12'!destinationFloor: anObject	destinationFloor := anObject! !!LiftFisika methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:12'!goUp	^ goUp! !!LiftFisika methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:12'!goUp: anObject	goUp := anObject! !!LiftFisika methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:12'!manCount	^ manCount! !!LiftFisika methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:12'!manCount: anObject	manCount := anObject! !!LiftFisika methodsFor: 'as yet unclassified' stamp: 'ss 5/26/2009 00:53'!calculate: aLift	self goUp: aLift goUp .		aLift goUp 		ifTrue: [self currFloor: aLift currFloor + 1]		ifFalse: [self currFloor: aLift currFloor - 1].			self currFloor > aLift content liftMine floorCount		ifTrue: [self currFloor: aLift currFloor - 1.				self goUp: false].				self currFloor < 1		ifTrue: [self currFloor: aLift currFloor + 1.				self goUp: true].				^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LiftFisika class	instanceVariableNames: ''!Object subclass: #LiftMan	instanceVariableNames: 'namez currFloor destinationFloor inLift needIn content mind'	classVariableNames: ''	poolDictionaries: ''	category: 'SLift-Model'!!LiftMan methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:13'!content	^ content! !!LiftMan methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:13'!content: anObject	content := anObject! !!LiftMan methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:13'!currFloor	^ currFloor! !!LiftMan methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:13'!currFloor: anObject	currFloor := anObject! !!LiftMan methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:13'!destinationFloor	^ destinationFloor! !!LiftMan methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:13'!destinationFloor: anObject	destinationFloor := anObject! !!LiftMan methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:13'!inLift	^ inLift! !!LiftMan methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:13'!inLift: anObject	inLift := anObject! !!LiftMan methodsFor: 'accessing' stamp: 'spectr 5/12/2009 22:44'!mind	mind isNil ifTrue: [self mind: LiftManMind new].	^ mind! !!LiftMan methodsFor: 'accessing' stamp: 'spectr 5/12/2009 22:43'!mind: anObject	mind := anObject! !!LiftMan methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:13'!namez	^ namez! !!LiftMan methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:13'!namez: anObject	namez := anObject! !!LiftMan methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:13'!needIn	^ needIn! !!LiftMan methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:13'!needIn: anObject	needIn := anObject! !!LiftMan methodsFor: 'initialize-release' stamp: 'spectr 5/12/2009 22:44'!initialize	self namez: ManNamez giveName .	self inLift: false.	self needIn: false.	self setCurrFloor.	self destinationFloor: self currFloor .	! !!LiftMan methodsFor: 'initialize-release' stamp: 'ss 5/26/2009 00:43'!setCurrFloor	| tempFloor |	tempFloor := 6 atRandom.	tempFloor <= 0		ifTrue: [tempFloor := 6].	"tempFloor > 6		ifTrue: [tempFloor := 1]."	self currFloor: tempFloor.! !!LiftMan methodsFor: 'creation' stamp: 'spectr 4/23/2009 23:51'!setContent: aContent	aContent class = LiftContent		ifTrue: [self content: aContent]		ifFalse: [^false].		^true.! !!LiftMan methodsFor: 'as yet unclassified' stamp: 'G.S. 3/29/2012 12:59'!in"trying to get in lift"	self content unitOfWork needFrom: self currFloor .	[self inLift ] whileFalse: ["Transcript cr; show: self namez, ' try in'."		self tryWait:(self content liftSem canIn at: self currFloor).		self tryIn.].		(self content liftSem canIn at: self currFloor) signal . "if requests need"! !!LiftMan methodsFor: 'as yet unclassified' stamp: 'G.S. 3/29/2012 13:05'!live"live of individual man"	[true] whileTrue: [self needIn		ifTrue: [			self in.			Transcript cr; show: self namez, ' in - ', self inLift asString.			]		ifFalse: [self inLift  					ifTrue: [self out.							Transcript cr; show: self namez, ' out'.]					ifFalse: [Transcript cr; show: self namez, ' think'.							self think.							Transcript cr; show: self namez, ' on - ',self currFloor asString .]				]].! !!LiftMan methodsFor: 'as yet unclassified' stamp: 'G.S. 3/29/2012 13:00'!out"trying to get out of lift"	self content unitOfWork needFrom: self currFloor  to: self destinationFloor .	[self inLift ] whileTrue: ["Transcript cr; show: self namez, ' try out by canOut wait'."		self tryWait: (self content liftSem canOut at: self currFloor).		self tryOut.].		(self content liftSem canOut at: self currFloor) signal.	"if requests need"	! !!LiftMan methodsFor: 'as yet unclassified' stamp: 'ss 5/26/2009 00:13'!think	(self mind think: self)		ifTrue: [self needIn: self mind needIn .				self destinationFloor: self mind destinationFloor .				self currFloor: self mind currFloor .]! !!LiftMan methodsFor: 'as yet unclassified' stamp: 'spectres 5/13/2009 10:52'!tryIn	(self mind canIn: self)		ifTrue: [self needIn: self mind needIn .				self inLift: self mind inLift .]! !!LiftMan methodsFor: 'as yet unclassified' stamp: 'ss 5/26/2009 00:11'!tryOut	(self mind canOut: self)		ifTrue: [self currFloor: self mind currFloor .				self destinationFloor: self mind destinationFloor .				self inLift: self mind inLift .				self needIn: self mind needIn .]! !!LiftMan methodsFor: 'as yet unclassified' stamp: 'ss 5/26/2009 03:51'!tryWait: aSem	aSem isSignaled 		ifTrue: [aSem wait.]		ifFalse: [(Delay forSeconds: 0.2) wait]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LiftMan class	instanceVariableNames: ''!!LiftMan class methodsFor: 'as yet unclassified' stamp: 'spectr 4/23/2009 23:50'!createWith: aContent	| model |	model := self new.	(model setContent: aContent) = false		ifTrue: [^false].	^model.! !Object subclass: #LiftManMind	instanceVariableNames: 'currFloor destinationFloor needIn inLift'	classVariableNames: ''	poolDictionaries: ''	category: 'SLift-Model'!!LiftManMind methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:13'!currFloor	^ currFloor! !!LiftManMind methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:13'!currFloor: anObject	currFloor := anObject! !!LiftManMind methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:14'!destinationFloor	^ destinationFloor! !!LiftManMind methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:14'!destinationFloor: anObject	destinationFloor := anObject! !!LiftManMind methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:14'!inLift	^ inLift! !!LiftManMind methodsFor: 'accessing' stamp: 'spectr 5/12/2009 23:04'!inLift: anObject	inLift := anObject	! !!LiftManMind methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:14'!needIn	^ needIn! !!LiftManMind methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:14'!needIn: anObject	needIn := anObject! !!LiftManMind methodsFor: 'as yet unclassified' stamp: 'G.S. 3/29/2012 13:08'!goInLift"get in lift"	self needIn: false.	self inLift: true.	^true! !!LiftManMind methodsFor: 'as yet unclassified' stamp: 'G.S. 3/29/2012 13:09'!goOutLift: aMan"try to get out of lift"	(aMan content unitOfWork exitFrom: aMan currFloor at: aMan destinationFloor) = false		ifTrue: [^false].			self inLift: false.	self currFloor: aMan destinationFloor.	self destinationFloor: 0.	self needIn: false.	^true! !!LiftManMind methodsFor: 'use' stamp: 'G.S. 3/29/2012 13:13'!canIn: aMan"can i get in?"	(aMan content lift wantIn: aMan currFloor )		ifTrue: [^self goInLift]		ifFalse: [^false]! !!LiftManMind methodsFor: 'use' stamp: 'G.S. 3/29/2012 13:15'!canOut: aMan"can i get out of lift?"	(aMan content lift wantOut: aMan destinationFloor) 		ifTrue: [^self goOutLift: aMan ]		ifFalse: [^false]! !!LiftManMind methodsFor: 'use' stamp: 'G.S. 3/29/2012 13:11'!think: aMan"think that floor man need"	(Delay forSeconds: 20) wait. "thinking delay... "		self needIn: true.	self currFloor: aMan currFloor .	self destinationFloor: (LiftMine genFloor: aMan content liftMine).	^true! !Object subclass: #LiftManRequests	instanceVariableNames: 'list countWanted allCount content'	classVariableNames: ''	poolDictionaries: ''	category: 'SLift-Model'!!LiftManRequests commentStamp: 'spectr 5/1/2009 15:19' prior: 0!countWanted is not used!!LiftManRequests methodsFor: 'accessing' stamp: 'spectr 5/1/2009 13:32'!allCount	allCount isNil ifTrue: [self allCount: 0].	^ allCount! !!LiftManRequests methodsFor: 'accessing' stamp: 'spectr 5/1/2009 13:32'!allCount: anObject	allCount := anObject! !!LiftManRequests methodsFor: 'accessing' stamp: 'spectr 5/1/2009 16:37'!content	^ content! !!LiftManRequests methodsFor: 'accessing' stamp: 'ss 5/25/2009 23:19'!content: anObject	content := anObject.	self initializeCounts .! !!LiftManRequests methodsFor: 'accessing' stamp: 'spectr 4/30/2009 05:00'!countWanted	^ countWanted! !!LiftManRequests methodsFor: 'accessing' stamp: 'spectr 4/30/2009 05:00'!countWanted: anObject	countWanted := anObject! !!LiftManRequests methodsFor: 'accessing' stamp: 'spectr 4/26/2009 18:34'!list	list isNil ifTrue: [self list: OrderedCollection  new].	^ list! !!LiftManRequests methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:59'!list: anObject	list := anObject! !!LiftManRequests methodsFor: 'initialize-release' stamp: 'ss 5/25/2009 23:18'!initialize	super initialize.	! !!LiftManRequests methodsFor: 'initialize-release' stamp: 'G.S. 3/29/2012 13:43'!initializeCounts	| temp |	temp := Dictionary new.	1 to: self content liftMine floorCount do: [:index |		temp at: index put: 0.].		self countWanted: temp.! !!LiftManRequests methodsFor: 'find' stamp: 'ss 5/26/2009 02:27'!InAt: aFloor	self list detect: [:x | x key = aFloor ] ifNone: [^(self countWanted at: aFloor) > 0].	^true! !!LiftManRequests methodsFor: 'find' stamp: 'ss 5/26/2009 02:45'!isNoWant	self countWanted detect: [ :e | e value > 0 ] ifNone: [^false].	^true! !!LiftManRequests methodsFor: 'find' stamp: 'G.S. 3/29/2012 14:18'!mostPopular"not used functional"	| popularFloor temp subTemp |	popularFloor := 1.	temp := [(self countWanted at: 1) / self allCount] on: Error do: [^popularFloor ] .	2 to: self content liftMine floorCount do: [:index | 		(subTemp := (self countWanted at: index) / self allCount) > temp			ifTrue: [temp := subTemp.					popularFloor := index]].				^popularFloor .! !!LiftManRequests methodsFor: 'find' stamp: 'ss 5/26/2009 00:40'!moveFrom: aFloor	^self list reject:  [:x | x value = aFloor ].! !!LiftManRequests methodsFor: 'find' stamp: 'spectr 5/1/2009 21:47'!outAt: aFloor	self list detect: [:x | x value = aFloor ] ifNone: [^false].	^true! !!LiftManRequests methodsFor: 'addReq' stamp: 'spectr 5/12/2009 22:36'!addCall: aFloor	"self countWanted at: aFloor put: (self countWanted at: aFloor) + 1."	self addWant: aFloor.	self allCount: (self allCount + 1).! !!LiftManRequests methodsFor: 'addReq' stamp: 'spectr 5/1/2009 21:49'!addReqAt: cFloor	self list add: cFloor->0.	self addCall: cFloor.! !!LiftManRequests methodsFor: 'addReq' stamp: 'spectr 5/1/2009 15:19'!addReqAt: cFloor to: dFloor	self list add: cFloor->dFloor.	"self addWant: dFloor ."! !!LiftManRequests methodsFor: 'addReq' stamp: 'ss 5/27/2009 11:13'!addWant: aFloor	self countWanted at: aFloor put: (self countWanted at: aFloor) + 1.	self content liftSem refresh signal.! !!LiftManRequests methodsFor: 'delReq' stamp: 'spectr 5/12/2009 21:59'!delReqFrom: cFloor and: dFloor	"request this method for del all kind of req"	| index |	index := self list indexOf: cFloor->dFloor.	[self list removeAt: index] on: Error do: [^false]"ifAbsent: [^false]".	^true! !!LiftManRequests methodsFor: 'delReq' stamp: 'ss 5/25/2009 21:37'!delWant: aFloor	self countWanted at: aFloor put: (self countWanted at: aFloor) - 1.	^true! !!LiftManRequests methodsFor: 'delReq' stamp: 'spectr 5/12/2009 22:13'!leaveLiftFrom: cFloor at: dFloor	"man request this method then leave lift"	^self delReqFrom: cFloor  and: dFloor		! !!LiftManRequests methodsFor: 'delReq' stamp: 'spectr 5/12/2009 22:15'!liftOn: aFloor	"request this method then lift getOn aFloor by man call"	^self delReqFrom: aFloor  and: 0 .! !Object subclass: #LiftMine	instanceVariableNames: 'floorCount powerOn'	classVariableNames: ''	poolDictionaries: ''	category: 'SLift-Model'!!LiftMine commentStamp: 'G.S. 3/29/2012 12:26' prior: 0!A LiftMine is working with power and define max number of floors.Instance Variables	floorCount:		<Object>	powerOn:		<Object>floorCount	- xxxxxpowerOn	- xxxxx!!LiftMine methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:14'!floorCount	^ floorCount! !!LiftMine methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:14'!floorCount: anObject	floorCount := anObject! !!LiftMine methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:14'!powerOn	^ powerOn! !!LiftMine methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:14'!powerOn: anObject	powerOn := anObject! !!LiftMine methodsFor: 'initialize-release' stamp: 'spectr 4/23/2009 23:32'!initialize	self powerOn: false.	self floorCount: 6.! !!LiftMine methodsFor: 'as yet unclassified' stamp: 'spectr 4/26/2009 17:17'!isOn	^self powerOn.! !!LiftMine methodsFor: 'as yet unclassified' stamp: 'ss 5/27/2009 00:57'!powerChange	self powerOn 		ifFalse: [self powerOn: true]		ifTrue: [self powerOn: false].! !!LiftMine methodsFor: 'as yet unclassified' stamp: 'spectr 4/26/2009 17:17'!turnOff	self powerOn 		ifTrue: [self powerOn: false].! !!LiftMine methodsFor: 'as yet unclassified' stamp: 'spectr 4/26/2009 17:16'!turnOn	self powerOn 		ifFalse: [self powerOn: true].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LiftMine class	instanceVariableNames: ''!!LiftMine class methodsFor: 'as yet unclassified' stamp: 'ss 5/25/2009 23:01'!genFloor: aMine	| numb |	numb := aMine floorCount atRandom.		numb < 1		ifTrue: [numb := 1].			^numb.! !Object subclass: #LiftSem	instanceVariableNames: 'canIn canOut refresh allIn allOut evaluate requests'	classVariableNames: ''	poolDictionaries: ''	category: 'SLift-Model'!!LiftSem commentStamp: 'G.S. 3/29/2012 12:23' prior: 0!A LiftSem is place there all semaphors are.Instance Variables	allIn:		<Object>	allOut:		<Object>	canIn:		<Object>	canOut:		<Object>	evaluate:		<Object>	refresh:		<Object>	requests:		<Object>allIn	- xxxxxallOut	- xxxxxcanIn	- xxxxxcanOut	- xxxxxevaluate	- xxxxxrefresh	- xxxxxrequests	- xxxxx!!LiftSem methodsFor: 'accessing' stamp: 'spectr 4/26/2009 17:50'!allIn	allIn isNil ifTrue: [self allIn: Semaphore new.].	^ allIn! !!LiftSem methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:14'!allIn: anObject	allIn := anObject! !!LiftSem methodsFor: 'accessing' stamp: 'spectr 4/26/2009 17:50'!allOut	allOut  isNil ifTrue: [self allOut: Semaphore new.].	^ allOut! !!LiftSem methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:14'!allOut: anObject	allOut := anObject! !!LiftSem methodsFor: 'accessing' stamp: 'G.S. 3/29/2012 13:55'!canIn	canIn isNil ifTrue: [self canIn: (self genSemCount: 6)]. "floors+1"	^ canIn! !!LiftSem methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:15'!canIn: anObject	canIn := anObject! !!LiftSem methodsFor: 'accessing' stamp: 'G.S. 3/29/2012 13:55'!canOut	canOut isNil ifTrue: [self canOut: (self genSemCount: 6)]. "floors+1"	^ canOut! !!LiftSem methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:15'!canOut: anObject	canOut := anObject! !!LiftSem methodsFor: 'accessing' stamp: 'spectr 5/1/2009 16:35'!evaluate	evaluate isNil ifTrue: [self evaluate: Mutex new].	^ evaluate! !!LiftSem methodsFor: 'accessing' stamp: 'spectr 5/1/2009 16:34'!evaluate: anObject	evaluate := anObject! !!LiftSem methodsFor: 'accessing' stamp: 'spectr 4/26/2009 17:51'!refresh	refresh isNil ifTrue: [self refresh: Semaphore new.].	^ refresh! !!LiftSem methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:15'!refresh: anObject	refresh := anObject! !!LiftSem methodsFor: 'accessing' stamp: 'spectr 5/1/2009 16:43'!requests	requests isNil ifTrue: [self requests: Semaphore new.].	^ requests! !!LiftSem methodsFor: 'accessing' stamp: 'spectr 5/1/2009 16:43'!requests: anObject	requests := anObject! !!LiftSem methodsFor: 'as yet unclassified' stamp: 'ss 5/26/2009 03:16'!genSemCount: aCount	| temp |	temp := Dictionary new.	1 to: aCount do: [:x | temp at: x put: Semaphore new].	^temp.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LiftSem class	instanceVariableNames: ''!Object subclass: #LiftUnitOfWork	instanceVariableNames: 'requests modifyed'	classVariableNames: ''	poolDictionaries: ''	category: 'SLift-Model'!!LiftUnitOfWork methodsFor: 'accessing' stamp: 'spectr 4/26/2009 17:46'!modifyed	^ modifyed! !!LiftUnitOfWork methodsFor: 'accessing' stamp: 'spectr 4/26/2009 17:46'!modifyed: anObject	modifyed := anObject! !!LiftUnitOfWork methodsFor: 'accessing' stamp: 'ss 5/25/2009 23:16'!requests	requests isNil ifTrue: [self requests: LiftManRequests new].	^ requests! !!LiftUnitOfWork methodsFor: 'accessing' stamp: 'spectr 4/23/2009 23:15'!requests: anObject	requests := anObject! !!LiftUnitOfWork methodsFor: 'as yet unclassified' stamp: 'ss 5/26/2009 00:54'!allOutAt: aFloor	^self requests outAt: aFloor! !!LiftUnitOfWork methodsFor: 'as yet unclassified' stamp: 'ss 5/26/2009 02:14'!isAllIn	"is all man in or all places is busy"	| lift |	lift := self requests content lift.	lift manCount = lift manMax 		ifTrue: [^true].			^self wantInAt: lift currFloor ! !!LiftUnitOfWork methodsFor: 'as yet unclassified' stamp: 'ss 5/25/2009 20:42'!wantInAt: aFloor	"bpode ? - is some one in"	^self requests InAt: aFloor.! !!LiftUnitOfWork methodsFor: 'as yet unclassified' stamp: 'spectr 5/11/2009 22:53'!wantMoveFrom: aFloor	"send lift then testGo"	| temp |	temp := self requests moveFrom: aFloor.	temp size = 0		ifTrue: [^false].			^temp! !!LiftUnitOfWork methodsFor: 'as yet unclassified' stamp: 'spectr 5/1/2009 21:51'!wantOutAt: aFloor	^self requests outAt: aFloor.! !!LiftUnitOfWork methodsFor: 'initialize-release' stamp: 'ss 5/25/2009 23:15'!initialize	super initialize.	self modifyed: false.! !!LiftUnitOfWork methodsFor: 'initialize-release' stamp: 'spectr 5/1/2009 16:39'!setup: aObj	self requests content: aObj.! !!LiftUnitOfWork methodsFor: 'state' stamp: 'G.S. 3/29/2012 14:11'!informationObtained"if all requests obtained and no one waiting then no actions from lift required"	((self requests list size = 0) and:[self requests isNoWant])		ifTrue: [self modifyed: false].! !!LiftUnitOfWork methodsFor: 'state' stamp: 'G.S. 3/29/2012 14:11'!modify"signal that actions from lift required"	self modifyed 		ifFalse: [self modifyed: true.				self requests content liftSem requests signal.].! !!LiftUnitOfWork methodsFor: 'change base' stamp: 'ss 5/26/2009 01:48'!exitFrom: cFloor at: dFloor	Transcript cr; show: 'exit from - ',cFloor asString, ' at - ', dFloor asString.	self requests leaveLiftFrom: cFloor at: dFloor.	self informationObtained.! !!LiftUnitOfWork methodsFor: 'change base' stamp: 'G.S. 3/29/2012 14:08'!finishOn: aFloor"send lift before move"	Transcript cr; show: 'lift on - ',aFloor asString.	(self requests liftOn: aFloor) = false 		ifFalse: [self finishOn: aFloor] "in circle del all requests from floor"		ifTrue: [self informationObtained.]."finishOn: aFloor	Transcript cr; show: 'lift on - ',aFloor asString.	(self requests liftOn: aFloor) = false		ifFalse: [self informationObtained.]"! !!LiftUnitOfWork methodsFor: 'change base' stamp: 'G.S. 3/29/2012 12:52'!manGoToLiftAt: aFloor "remove request to get in to lift"	^ self requests delWant: aFloor! !!LiftUnitOfWork methodsFor: 'change base' stamp: 'ss 5/25/2009 23:57'!needFrom: cFloor 	Transcript cr; show: 'need from - ',cFloor asString.	self requests addReqAt: cFloor.	self modify.! !!LiftUnitOfWork methodsFor: 'change base' stamp: 'ss 5/25/2009 23:58'!needFrom: cFloor to: dFloor	"self requests getInLiftAt: cFloor."	Transcript cr; show: 'need from - ',cFloor asString, ' to - ', dFloor asString.	self requests addReqAt: cFloor to: dFloor .	self modify.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LiftUnitOfWork class	instanceVariableNames: ''!!LiftUnitOfWork class methodsFor: 'as yet unclassified' stamp: 'spectr 5/1/2009 13:57'!createWith: aObj	| model |	model := self new .	model		setup: aObj.	^model! !Object subclass: #ManNamez	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SLift-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManNamez class	instanceVariableNames: ''!!ManNamez class methodsFor: 'as yet unclassified' stamp: 'spectr 4/30/2009 04:49'!giveName	| nextName list |	list := {'Medved'. 'Serg'. 'Mari'. 'Alex'. 'Anna'. 'Robert'. 'Andre'. 'Alina'. 'Ivan'. 'Natalia'}.	nextName :=  list size atRandom.	nextName <= 0		ifTrue: [nextName := 1].	nextName > list size		ifTrue: [nextName := list size].			^list at: nextName .! !